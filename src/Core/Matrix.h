#ifndef Matrix_H
#define Matrix_H

// Libraries for the ietl sparse library
#include <boost/numeric/ublas/matrix_sparse.hpp>
#include <ietl/interface/ublas.h>
#include <ietl/power.h>
#include <ietl/vectorspace.h>
#include <ietl/iteration.h>
#include <ietl/lanczos.h>
#include <boost/random.hpp>
#include <boost/limits.hpp>

// Libraries for the eigen matrix libraries
#include <unistd.h>
#include "Eigen/Dense"
#include "Eigen/LU"
#include "Eigen/Cholesky"
#include <Eigen/Sparse>
#include <Eigen/SPQRSupport>
#include <Eigen/Eigenvalues>

#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <list>
#include <cassert>

// Lapack eigenvalue decomposition routine
extern "C"
{
void DGEEV(const char* CL, const char* CR, const int32_t&, double*,
           const int32_t&, double*, double*, double*, const int32_t&, double*,
           const int32_t&, double*, const int32_t&, int32_t&, long, long);
}

// Routines from arpack for sparse matrices
extern "C"
{
void dnaupd_(int32_t&, const char*, const int32_t&, const char*, int32_t&, const double&,
               double*, const int32_t&, double*, const int32_t&, int32_t*, int32_t*, double*, double*,
               const int32_t&, int32_t&, long, long);

void dneupd_( const int32_t&, const char*, int32_t*, double*, double*, double*, const int32_t&, const double&,
               const double&, double*, const char *, const int32_t&, const char*, int32_t&, const double&, double*,
               const int32_t&, double*, const int32_t&, int32_t*, int32_t*, double*, double*,
               const int32_t&, int32_t&, long, long, long);
}

// These matrices are dynamic and slower than their
// static counterparts. The speed difference is in the allocation
// of memory on the heap.
namespace Cu
{ // The namespace is necessary to avoid conflicts with another library, so it is also quite short
    typedef Eigen::MatrixXd Matrix;
    typedef Eigen::VectorXd Vector;
    typedef Eigen::MatrixXcd ComplexMatrix;
    typedef Eigen::VectorXcd ComplexVector;
    typedef Eigen::SparseMatrix<double> SPMatrix;

    typedef boost::numeric::ublas::mapped_matrix<double> SparseMatrix;
    typedef boost::numeric::ublas::vector<double> BlasVector;

    void print_matrix(const Cu::Matrix&, const std::string&);
    void print_matrix_octave(const Cu::Matrix&, const std::string&);
    void print_matrix_octave(const std::vector<std::vector<double>>& A, const std::string& name);
    void print_matrix_octave(const double* data, const uint32_t M, const uint32_t N, const std::string& name, bool binary=false);
    void print_matrix_octave(const uint32_t* data, const uint32_t M, const uint32_t N, const std::string& name, bool binary=false);
    void print_matrix_octave(const uint32_t* data, const uint32_t M, const uint32_t N, const uint32_t K, const std::string& name);
    void print_matrix_octave(const double* data, const uint32_t M, const uint32_t N, const uint32_t K, const std::string& name, bool binary=false);

    typedef std::pair< std::vector<double> , std::vector<uint32_t> > DataDims;
    DataDims read_matrix_octave(const std::string &filename, std::string& name);
    void transpose(std::vector<double>& A, uint32_t M, uint32_t N);

    Matrix read_matrix_bundler( const std::string& filename );
}

typedef std::vector<double> Vertex;
typedef std::vector<uint32_t> Face;
typedef std::vector< Vertex > Vertices;
typedef std::vector< Face > Faces;
typedef std::pair< Vertices, Faces > VerticesFaces;

Cu::Matrix ConvertToEigen(const double *in, const uint32_t M, const uint32_t N );


/**
 * @brief FindConnectedVertices
 * Return all of the vertex indices connected thorugh an edge to the specified vertex
 * @return
 */
std::set<uint32_t> FindConnectedVertices( const uint32_t vertex, const Faces& faces );

/**
 * @brief FindConnectedVertices
 * Return the vertices in a connected face list, generated by 'FindConnectedFaces'.
 * The function only computes the unique vertex elemetns in the connected set of faces.
 * @return
 */
std::set<uint32_t> FindConnectedVertices(const std::list<uint32_t>& connectedfacelist, const Faces& faces);


/**
 * @brief FindConnectedFaces
 * Return all of the face indices connected thorugh an edge to the specified vertex
 * @return
 */
std::list<uint32_t> FindConnectedFaces( const uint32_t vertex, const Faces& faces );

std::list<uint32_t> FindQuadrilateral( const uint32_t v1, const uint32_t v2, const std::list<uint32_t> connectedfacelist, const Faces& faces );



namespace MatrixFuncs
{
    void HomogeneousNormalise( Cu::Matrix& ); ///< Normalise a Cu::Cu::Matrix using homogeneous form
    std::vector<uint32_t> find( const Cu::Matrix& in, const std::function<bool(float)>& func  ); ///< Find indexes in the Cu::Cu::Matrix which satisfy the lambda function
    std::vector<uint32_t> unique( uint32_t* vec, uint32_t M );

    /**
     * @brief EigenValues
     * Return the eigenvectors and values of a matrix A. The eigenvectors are normalised by the determinant
     * of the matrix U, to ensure that the determinant is 1 and not -1. Either are valid solutions.
     * Only the real parts of the eigenvectors are returned.
     * @param A
     * @return
     */
    std::pair<Cu::Matrix, Cu::Matrix> EigenValues( const Cu::Matrix& A  );
    std::pair<Cu::ComplexMatrix, Cu::ComplexMatrix> EigenValuesLPCK( const Cu::Matrix& A  ); ///< Eigenvalues using lapack

    /**
     * @brief EigenValuesARPK
     * Compute eigenvalues of a sparse matrix using Arpack.
     * This computation is the fastest of all the sparse eigenvalue functions.
     * @param A - The sparse matrix
     * @param N - The number of eigenvalies to look for
     * @param takehighest - Take the highest if true - the lowest if false
     * @return A pair containing U and S
     */
    std::pair<Cu::ComplexMatrix, Cu::ComplexMatrix> EigenValuesARPK(const Cu::SPMatrix& A, int32_t K, const bool takehighest=false );

    /**
     * @brief EigenValues
     * Compute the eigen values of a sparse matrix using the lanczos method, which is described in,
     * J. K. Cullum and R. A. Willoughby, Lanczos algorithms for Large Symmetric Eigenvalue Computations. Volume 1, Theory
     * This  funciont uses the ietl library which can be found at http://www.comp-phys.org/software/ietl/.
     * This implemntation does not work very well. Use ARPK is possible.
     * @param A The sparse matrix
     * @param takehighest - Take the N highest eigen vectors if true, lowest if false
     * @param N - the number of eigenpairs to compute
     * @return A pair containing a matrix of eigenvectors U and a vector of eigenvalues S
     */
    std::pair<std::vector<Cu::BlasVector>, std::vector<double> > EigenValues( const Cu::SparseMatrix& A, bool takehighest=false, uint32_t N=10 );

    //void EigenValuesSS(const Cu::SPMatrix& A ); ///< Suite sparse eigenvalues

    Cu::Matrix diag(const Cu::Matrix& x); ///< Create a diagonal matrix from a vector
    Cu::Matrix Cos(const Cu::Matrix& x);
    Cu::Matrix Sin(const Cu::Matrix& x);
    Cu::Matrix ones(const uint32_t i, const uint32_t j);
    Cu::Matrix tril(const uint32_t i, const uint32_t j);
    Cu::Matrix triu(const uint32_t i, const uint32_t j);

    inline void Fast2DInvert( Cu::Matrix& A )
    {
        double DetA = A(0,0)*A(1,1) - A(0,1)*A(1,0);
        double A11 = A(1,1);
        double A01 = A(0,1);
        A(1,1) = A(0,0)/DetA;
        A(0,0) = A11/DetA;
        A(0,1) = -A(1,0)/DetA;
        A(1,0) = -A01/DetA;
    }

    inline void Fast2DInvert( double* A )
    {
        double DetA = A[0]*A[3] - A[2]*A[1];
        double A11 = A[3];
        double A01 = A[2];
        A[3] = A[0]/DetA;
        A[0] = A11/DetA;
        A[2] = -A[1]/DetA;
        A[1] = -A01/DetA;
    }

    inline void Fast2DMultiply( const Cu::Matrix A, Cu::Matrix& b)
    {
        double b0 = b(0);
        b(0) = A(0,0)*b0 + A(0,1)*b(1);
        b(1) = A(1,0)*b0 + A(1,1)*b(1);
    }

    inline void Fast2DMultiply( const double* A, double* b)
    {
        double b0 = b[0];
        b[0] = A[0]*b0 + A[2]*b[1];
        b[1] = A[1]*b0 + A[3]*b[1];
    }
}

namespace MeshFuncs
{
    void RemoveVerticesFaces(VerticesFaces& vf, std::vector<uint32_t> &VerticesToRemove );
        ///< Remove all faces and vertices from vf which contain the faces in FacesToRemove - note the second list is sorted
    void WritePly(const VerticesFaces& vf, const std::string filename);
    void WritePly(const VerticesFaces& vf, const std::vector< std::vector<double>>& vertexcolours, const std::string filename);


    /**
     * @brief Dijkstra
     * Find the geodesic distances on a point cloud (graph).
     * @param vertices The vertices (MxN) column major
     * @param M The dimension
     * @param nbs The nearest neighbours (KxN) column major
     * @param K The number of nearest neighbours
     * @param i The vertex index to find distances from
     * @param j The target vertex. The algorithm will stop when the distance to j is computed. If set to -1 it will compute all of the distances.
     * @return The geodesic distance to each of the points in the cloud
     */
    std::vector< double > Dijkstra(const std::vector<double>& vertices, const uint32_t M,
                                    const std::vector<std::vector<uint32_t> > &nbs,
                                    const uint32_t i, const int32_t j=-1);

    /**
     * @brief FindShortestPath
     * Find the shortest path from i to j.
     * This algorithm requires Dijkstras algorithm to be run to generate the distances vector
     * from i to j.
     * @param neighbours
     * @param distances
     * @param i
     * @param j
     * @return
     */
    std::list<uint32_t> FindShortestPath( const std::vector<std::vector<uint32_t> >& neighbours,
                                          const std::vector<double>& distances,
                                          const uint32_t i,
                                          const uint32_t j);


    struct DistanceIndex
    {
        uint32_t index;
        double distance;
    }; ///< Required for Dijkstras algorithm

    typedef std::set< DistanceIndex, std::function<bool(const DistanceIndex& l, const DistanceIndex& r)> >  DistanceSet; ///< Required for Dijkstras algorithm
}

namespace Funcs
{
    double normal_pdf(const double x, const double m, const double s);


    /* hsv2rgb.c
     * Convert Hue Saturation Value to Red Green Blue
     *
     * P.J. 08-Aug-98
     *
     * Reference:
     * D. F. Rogers
     * Procedural Elements for Computer Graphics
     * McGraw Hill 1985
     */
    int hsv2rgb( const float h, const float s, const float v, float& r, float& g, float& b);
}

#endif // Cu::Matrix_H
